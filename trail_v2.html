
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- <link href="https://cdnjs.cloudflare.com/ajax/libs/flowbite/2.2.0/flowbite.min.css"  rel="stylesheet" /> -->
    <style>
    #c {
        background-color: white;
      }
      
      button {
        padding: 10px 20px;
      }
      </style>
      <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
      <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/flowbite/2.2.0/flowbite.min.js"></script> -->
      <script src="./js/fabric.js"></script>
      <style>
        .context-menu {
            opacity: 0.7;
            background: #282828;
            color: #E086D3;
            position: absolute;
            top:-140%;
            left: -25%;
            border-radius: 5px;
            /* font: 16px; */
            height: 20px;
            /* box-shadow: 0 0 30px rgba(0, 0, 0, 0.01); */
            z-index: 10000 !important;
            display: none;
        }
        /* tooltip  after*/
        .context-menu::after {
            content: " ";
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 10px 10px 0 10px;
            border-color: #282828 transparent transparent transparent;
            opacity: 1;
            position: absolute;
            left: 40%;
        }


        .button-container{
            display:flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            height:100%;
            padding:0px 0.5px;
        }
        .btn
        {
            border: none;
            background-color: transparent;
            width: 100%;
            font-size: 0.5em;
            font-family: "Quicksand", sans-serif;
            font-weight: 600;
            color: #e8e8e8;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            justify-content:center;
            align-items: center;
            height: 100%;
            padding: 0%;
        }
        .btn:hover{
            border-radius: 5px;
            background-color: rgb(219, 213, 213, 0.3);
        }
        .btn p
        {
            width: 100%;
            height: 100%;
            text-align: left;
            transition: background-color 0.15s;
            border-radius: 3px;
            display: flex;
            align-items: center;
            padding: 0px;
            color: white;
            margin: 3px;
            font-size: 6px;
        }
        .btn:hover div
        {
        background-color: rgba(147, 147, 147, 0.31);
        }
        #blue
        {
        padding : 0px 0;
        }
        #green
        {
        padding : 0px 0;
        }
        #orange {
        padding : 0px 0;
        }
        .vertical {
        border: 1px solid #4d4d4d;
        height: 80%
        }
        #canvas-container{
            /* background: #E086D3; */
            /* R: Only for testing */
            /* height: 85vh; */
        }
      </style>
</head>
<body>
    <div style="display: flex; flex-direction: column;">
        <div>
            <div style="display: flex;justify-content: center;">
                <button id="rect">Rect</button>
                <button id="circ">Circ</button>
                <button id="save">Save</button>
                <button id="undo">undo</button>
                <button id="redo">redo</button>
                <button id="clear">clear</button>
                <button id="drawing-mode" drawing=true>Cancel drawing mode</button><br>
                <p class="save"></p>
                <input type="text" id="text" />
            </div>
            <div style="display: inline-block; margin-left: 10px">
                <div id="drawing-mode-options">
                  <label for="drawing-mode-selector">Mode:</label>
                  <select id="drawing-mode-selector">
                    <option>Pencil</option>
                    <option>Circle</option>
                    <option>Spray</option>
                    <option>Pattern</option>
              
                    <option>hline</option>
                    <option>vline</option>
                    <option>square</option>
                    <option>diamond</option>
                    <option>texture</option>
                  </select><br>
              
                  <label for="drawing-line-width">Line width:</label>
                  <span class="info">30</span><input type="range" value="30" min="0" max="150" id="drawing-line-width"><br>
              
                  <label for="drawing-color">Line color:</label>
                  <input type="color" value="#005E7A" id="drawing-color"><br>
              
                  <label for="drawing-shadow-color">Shadow color:</label>
                  <input type="color" value="#005E7A" id="drawing-shadow-color"><br>
              
                  <label for="drawing-shadow-width">Shadow width:</label>
                  <span class="info">0</span><input type="range" value="0" min="0" max="50" id="drawing-shadow-width"><br>
              
                  <label for="drawing-shadow-offset">Shadow offset:</label>
                  <span class="info">0</span><input type="range" value="0" min="0" max="50" id="drawing-shadow-offset"><br>
                </div>
              </div>
        </div>
        <div style="display: flex;justify-content: center;" id="canvas-container">
            <canvas id="c" width="600" height="600" style="border:1px solid #000000"></canvas>
        </div>
    </div>

    <div class="context-menu" id="context-menu">
        <div class="button-container">
          <button class="btn" id="group"><p id="groupText"> Group </p></button>
          <div class="vertical"></div>
          <button class="btn" id="copy" ><p> Copy </p></button>
          <div class="vertical"></div>
          <button class="btn" id="paste"><p> Paste </p></button>
        </div>
      </div>
      <script src="//cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
      
      <!-- <script>
            
            const orange = document.querySelector("#orange");
            const blue = document.querySelector("#blue");
            const green = document.querySelector("#green");


            document.addEventListener('DOMContentLoaded', (event) => {
                const menu = document.querySelector(".context-menu");
                const canvaswall = document.querySelector("#c");
                canvaswall.addEventListener("contextmenu", function(e) {
                    // Show the context menu
                menu.style.display = "block";
                
                // just for the pen :
                menu.style.transform = "translate(0)";
                
                // set position X of the menu
                if ((window.innerWidth - e.clientX) > menu.offsetWidth + 10){
                    menu.style.left = e.clientX + "px";
                }
                else
                {
                    menu.style.left = (e.clientX - menu.offsetWidth) + "px";
                }
                // set position Y of the menu
                if ((e.clientY) > menu.offsetHeight + 10){   
                menu.style.top = (e.clientY - menu.offsetHeight) + "px";
                }
                else
                {
                    menu.style.top = e.clientY + "px";
                }
                })

                //exit the context menu
                window.addEventListener("click", function(){
                    menu.style.display = "none";
                })
            });
    
            
            
      </script> -->
 
    <script>
        // function calculateHash(obj) {
        //     const hash = CryptoJS.MD5(obj).toString();
        //     return hash;
        // }

        var canvasHistory = [];
        var currentIndex = -1;
        var isUndoRedoOperation = false;
        var historySizeLimit = 20; // Set the maximum size of the history
        var drawingModeEl = document.getElementById('drawing-mode');
        var isDrawing = drawingModeEl.getAttribute('drawing');

        var drawingOptionsEl = document.getElementById('drawing-mode-options');
        var drawingColorEl = document.getElementById('drawing-color');
        var drawingShadowColorEl = document.getElementById('drawing-shadow-color');
        var drawingLineWidthEl = document.getElementById('drawing-line-width');
        var drawingShadowWidth = document.getElementById('drawing-shadow-width');
        var drawingShadowOffset = document.getElementById('drawing-shadow-offset');
        var canvas = new fabric.Canvas('c',{
            fireRightClick: true,
            stopContextMenu: true,
            isDrawingMode: isDrawing
        });

        fabric.Object.prototype.transparentCorners = false;
        
        drawingModeEl.onclick = function() {
            canvas.isDrawingMode = !canvas.isDrawingMode;
            if (canvas.isDrawingMode) {
            drawingModeEl.innerHTML = 'Cancel drawing mode';
            drawingOptionsEl.style.display = '';
            }
            else {
            drawingModeEl.innerHTML = 'Enter drawing mode';
            // drawingOptionsEl.style.display = 'none';
            }
        };
        
// start check
// start check
// start check
// start check
// start check
// start check
// start check
        if (fabric.PatternBrush) {
            var vLinePatternBrush = new fabric.PatternBrush(canvas);
            vLinePatternBrush.getPatternSrc = function() {

            var patternCanvas = fabric.document.createElement('canvas');
            patternCanvas.width = patternCanvas.height = 20;
            var ctx = patternCanvas.getContext('2d');

            ctx.strokeStyle = this.color;
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(0, 5);
            ctx.lineTo(10, 5);
            ctx.closePath();
            ctx.stroke();

            return patternCanvas;
            };

            var hLinePatternBrush = new fabric.PatternBrush(canvas);
            hLinePatternBrush.getPatternSrc = function() {

            var patternCanvas = fabric.document.createElement('canvas');
            patternCanvas.width = patternCanvas.height = 10;
            var ctx = patternCanvas.getContext('2d');

            ctx.strokeStyle = this.color;
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(5, 0);
            ctx.lineTo(5, 10);
            ctx.closePath();
            ctx.stroke();

            return patternCanvas;
            };

            var squarePatternBrush = new fabric.PatternBrush(canvas);
            squarePatternBrush.getPatternSrc = function() {

            var squareWidth = 10, squareDistance = 2;

            var patternCanvas = fabric.document.createElement('canvas');
            patternCanvas.width = patternCanvas.height = squareWidth + squareDistance;
            var ctx = patternCanvas.getContext('2d');

            ctx.fillStyle = this.color;
            ctx.fillRect(0, 0, squareWidth, squareWidth);

            return patternCanvas;
            };

            var diamondPatternBrush = new fabric.PatternBrush(canvas);
            diamondPatternBrush.getPatternSrc = function() {

            var squareWidth = 10, squareDistance = 5;
            var patternCanvas = fabric.document.createElement('canvas');
            var rect = new fabric.Rect({
                width: squareWidth,
                height: squareWidth,
                angle: 45,
                fill: this.color
            });

            var canvasWidth = rect.getBoundingRect().width;

            patternCanvas.width = patternCanvas.height = canvasWidth + squareDistance;
            rect.set({ left: canvasWidth / 2, top: canvasWidth / 2 });

            var ctx = patternCanvas.getContext('2d');
            rect.render(ctx);

            return patternCanvas;
            };

            // var img = new Image();
            // img.src = '../assets/honey_im_subtle.png';

            // var texturePatternBrush = new fabric.PatternBrush(canvas);
            // texturePatternBrush.source = img;
        }

        let drawingModeSelector = document.getElementById('drawing-mode-selector');

drawingModeSelector.onchange = function() {
    let isDrawingTool = ['hline', 'vline', 'square', 'diamond', 'texture', 'Pencil', 'Circle', 'Spray', 'Pattern'].includes(this.value);

    if (isDrawingTool) {
        canvas.isDrawingMode = true;

        switch (this.value) {
            case 'hline':
                canvas.freeDrawingBrush = vLinePatternBrush;
                break;
            case 'vline':
                canvas.freeDrawingBrush = hLinePatternBrush;
                break;
            // Add cases for other drawing tools...
            default:
                canvas.freeDrawingBrush = new fabric[this.value + 'Brush'](canvas);
        }
    } else {
        canvas.isDrawingMode = false;
    }

    if (canvas.freeDrawingBrush) {
        canvas.freeDrawingBrush.color = drawingColorEl.value;
        canvas.freeDrawingBrush.width = parseInt(drawingLineWidthEl.value, 10) || 1;
        canvas.freeDrawingBrush.shadow = new fabric.Shadow({
            blur: parseInt(drawingShadowWidth.value, 10) || 0,
            offsetX: 0,
            offsetY: 0,
            affectStroke: true,
            color: drawingShadowColorEl.value,
        });
    }
};

        drawingColorEl.onchange = function() {
            canvas.freeDrawingBrush.color = this.value;
        };
        drawingShadowColorEl.onchange = function() {
            canvas.freeDrawingBrush.shadow.color = this.value;
        };
        drawingLineWidthEl.onchange = function() {
            canvas.freeDrawingBrush.width = parseInt(this.value, 10) || 1;
            this.previousSibling.innerHTML = this.value;
        };
        drawingShadowWidth.onchange = function() {
            canvas.freeDrawingBrush.shadow.blur = parseInt(this.value, 10) || 0;
            this.previousSibling.innerHTML = this.value;
        };
        drawingShadowOffset.onchange = function() {
            canvas.freeDrawingBrush.shadow.offsetX = parseInt(this.value, 10) || 0;
            canvas.freeDrawingBrush.shadow.offsetY = parseInt(this.value, 10) || 0;
            this.previousSibling.innerHTML = this.value;
        };

        if (canvas.freeDrawingBrush) {
            canvas.freeDrawingBrush.color = drawingColorEl.value;
            canvas.freeDrawingBrush.width = parseInt(drawingLineWidthEl.value, 10) || 1;
            canvas.freeDrawingBrush.shadow = new fabric.Shadow({
            blur: parseInt(drawingShadowWidth.value, 10) || 0,
            offsetX: 0,
            offsetY: 0,
            affectStroke: true,
            color: drawingShadowColorEl.value,
            });
        }
        
// original code 
// original code 
// original code 
        // canvas.setBackgroundImage('http://lorempixel.com/400/400/fashion', canvas.renderAll.bind(canvas));

        $(document).bind('contextmenu', function(e) {
            e.preventDefault();
        });


        $("#text").on("click", function() {
            const text = new fabric.Text($("#text").val(), { left: 100, top: 100 });
            canvas.add(text);
        });

        $("#rect").on("click", function() {
            const rect = new fabric.Rect({
                left: 40, top: 40, width: 50, height: 50, fill: 'transparent', stroke: 'green', strokeWidth: 5
            });
            canvas.add(rect);
        });

        $("#circ").on("click", function() {
            const circle = new fabric.Circle({
                left: 40, top: 40, radius: 50, fill: 'transparent', stroke: 'green', strokeWidth: 5
            });
            canvas.add(circle);
        });


        // Function to save the current canvas state to history
        function saveToHistory() {
            if (!isUndoRedoOperation) {
                const currentCanvasState = JSON.stringify(canvas.toJSON());
                // Check if the current state is different from the last saved state
                const lastSavedState = canvasHistory[currentIndex];
                if (currentCanvasState !== lastSavedState) {
                    // Remove any future states if they exist
                    canvasHistory = canvasHistory.slice(0, currentIndex + 1);
                    currentIndex++;
                    canvasHistory[currentIndex] = JSON.stringify(canvas.toJSON());
                    // Drop the oldest states until the history size is within the limit
                    while (canvasHistory.length > historySizeLimit) {
                        canvasHistory.shift();
                        currentIndex--;
                        if (currentIndex < 0) {
                            currentIndex = 0; // Ensures currentIndex doesn't go below 0
                        }
                    }
                }
            }
        }

        // Fabric.js events to detect changes
        canvas.on('object:modified', saveToHistory);
        canvas.on('object:added', saveToHistory);
        const menu = document.querySelector("#context-menu");
        fabric.util.addListener(document.getElementsByClassName('upper-canvas')[0], 'contextmenu', function(e) {
            checkGroupedObjects();
            var cnvsPos = $('#canvas-container').offset();
            curX = e.clientX + cnvsPos.left - 40;
            console.log(curX,cnvsPos.left);
            curY = e.clientY - cnvsPos.top/4;
            console.log(curY,cnvsPos.top);
            // curX = e.clientX - menu.offsetWidth/2;
            // curY = e.clientY - menu.offsetHeight - 10;
            $('#context-menu').css({'top': curY, 'left': curX}).fadeIn('fast');
            //console.log("Position of the cursor point" + curX + "," + curY);
        });
        $(document).click(function(event) {
        if (!$(event.target).closest('#context-menu').length) {
            if ($('#context-menu').css("display", "block")) {
                $('#context-menu').css("display", "none");
            }
        }
        });


        $(document).on('click', '#group', function(evt) {
            $('#context-menu').hide();
            if (isGrouped) {
                canvas.getActiveObject().toActiveSelection();
                canvas.requestRenderAll();
                isGrouped = false;
            } else {
                canvas.getActiveObject().toGroup();
                canvas.requestRenderAll();
            }
        });

        $(document).on('click', '#copy', function () {
            // clone what are you copying since you
            // may want copy and paste on different moment.
            // and you do not want the changes happened
            // later to reflect on the copy.
            $('#context-menu').hide();
            canvas.getActiveObject().clone(function(cloned) {
                _clipboard = cloned;
            });
        });

        $(document).on('click', '#paste', function Paste(e) {
            // clone again, so you can do multiple copies.
            
            $('#context-menu').hide();
            _clipboard.clone(function(clonedObj) {
                canvas.discardActiveObject();
                var pointer = canvas.getPointer(e);  // Transform the mouse coordinates
                clonedObj.set({
                    left: pointer.x,
                    top: pointer.y,
                    evented: true,
                });
                if (clonedObj.type === 'activeSelection') {
                    // active selection needs a reference to the canvas.
                    clonedObj.canvas = canvas;
                    clonedObj.forEachObject(function(obj) {
                        canvas.add(obj);
                    });
                    // this should solve the unselectability
                    clonedObj.setCoords();
                } else {
                    canvas.add(clonedObj);
                }
                _clipboard.top += 10;
                _clipboard.left += 10;
                canvas.setActiveObject(clonedObj);
                canvas.requestRenderAll();
            });
        });
        



        document.getElementById("undo").addEventListener("click", undo);
        function undo() {
            if (currentIndex > 0) {
                isUndoRedoOperation = true;
                currentIndex--;
                const previousState = canvasHistory[currentIndex];
                canvas.loadFromJSON(previousState, function() {
                    canvas.renderAll();
                    isUndoRedoOperation = false;
                });
            }
        }

        document.getElementById("redo").addEventListener("click", redo);
        function redo() {
            if (currentIndex < canvasHistory.length - 1) {
                isUndoRedoOperation = true;
                currentIndex++;
                const nextState = canvasHistory[currentIndex];
                canvas.loadFromJSON(nextState, function() {
                    canvas.renderAll();
                    isUndoRedoOperation = false;
                });
            }
        }

        document.getElementById("clear").addEventListener("click", function () {
            canvas.clear();
            console.log(canvasHistory);
            console.log(currentIndex);
            console.log(canvasHistory[currentIndex]);
            // canvas.setBackgroundColor('white', canvas.renderAll.bind(canvas));
            saveToHistory();
        });


        // Save initial state
        saveToHistory();

        document.addEventListener('keydown', function(event) {
            // Check if the Ctrl key is pressed (Ctrl key has key code 17)
            if (event.ctrlKey || event.metaKey) {
                // Check for Ctrl+Z (undo) on Windows or Command+Z on Mac
                if ((event.key === 'z' || event.key === 'Z') && !event.shiftKey) {
                    event.preventDefault(); // Prevent the browser's default Ctrl+Z or Command+Z behavior
                    undo(); // Call the undo function
                }
                // Check for Ctrl+R (redo) on Windows or Command+R on Mac
                else if ((event.key === 'r' || event.key === 'R') && !event.shiftKey) {
                    event.preventDefault(); // Prevent the browser's default Ctrl+R or Command+R behavior
                    redo(); // Call the redo function
                }
            }
        });


        // Function to remove the selected object
        function removeSelectedObject() {
            var activeObject = canvas.getActiveObject();
            if (activeObject) {
                canvas.remove(activeObject);
                saveToHistory();
            }
        }

        // Binding the Backspace key to remove the selected object
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Backspace' || event.key === 'Delete') {
                event.preventDefault(); // Prevent the default backspace action
                removeSelectedObject();
            }
        });


        $("#save").on("click", function(e) {
                    $(".save").html(canvas.toSVG());
        });

        let isGrouped;
        function checkGroupedObjects() {
            let grouptext = document.querySelector("#groupText");
            let activeObject = canvas.getActiveObject();
            // Check if there is an active object
            if (activeObject) {
                // Check if the active object is a group
                if (activeObject && activeObject.type === 'group') {
                    grouptext.style.display = "flex";
                    grouptext.textContent = "Ungroup";
                    isGrouped = true;
                } else {
                    grouptext.style.display = "flex";
                    grouptext.textContent = "Group";
                    isGrouped = false;
                }
            } else {
                // Default text or action when no object is selected
                    grouptext.style.display = "none";

            }
        }

// Sample data points
var dataPoints = [
    { x: 10, y: 50 }, 
    { x: 50, y: 30 },
    { x: 90, y: 70 },
    // Add more points as needed
];

// Function to draw a line between two points
function drawLine(point1, point2) {
    var line = new fabric.Line([point1.x, point1.y, point2.x, point2.y], {
        fill: 'black',
        stroke: 'black',
        strokeWidth: 2,
    });
    canvas.add(line);
}

// Draw the line plot
for (var i = 0; i < dataPoints.length - 1; i++) {
    drawLine(dataPoints[i], dataPoints[i + 1]);
}
    </script>
</body>
</html>

<!-- reference -->
<!-- https://codepen.io/ryjkmr/pen/KKWgVVP -->
<!-- https://codepen.io/Sampathkumar/pen/ZEaQXJ contextMenu -->
<!-- https://codepen.io/notarazi/pen/jaKRjm freedrawing -->

<!-- Bug report -->
<!-- 1. If you click several times on the clear button, duplicate save to history  #solved-->