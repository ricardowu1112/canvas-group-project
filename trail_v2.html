
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- <link href="https://cdnjs.cloudflare.com/ajax/libs/flowbite/2.2.0/flowbite.min.css"  rel="stylesheet" /> -->
    <style>
    #c {
        background-color: white;
      }
      
      button {
        padding: 10px 20px;
      }
      </style>
      <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
      <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/flowbite/2.2.0/flowbite.min.js"></script> -->
      <script src="./js/fabric.js"></script>
      <style>
#c {
        background-color: white;
      }
      
      button {
        padding: 10px 20px;
      }
.context-menu {
            /* opacity: 0.7; */
            background: #282828;
            position: absolute;
            top:-140%;
            left: -25%;
            border-radius: 5px;
            /* font: 16px; */
            height: 20px;
            /* box-shadow: 0 0 30px rgba(0, 0, 0, 0.01); */
            z-index: 10000 !important;
            display: none;
        }
        /* tooltip  after
        .context-menu::after {
            content: " ";
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 10px 10px 0 10px;
            border-color: #282828 transparent transparent transparent;
            opacity: 1;
            position: absolute;
            left: 40%;
        } */


        .button-container{
            display:flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            height:100%;
            padding:0px 0.5px;
        }
        .btn
        {
            border: none;
            background-color: transparent;
            width: 100%;
            font-size: 0.5em;
            font-family: "Quicksand", sans-serif;
            font-weight: 600;
            color: #e8e8e8;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            justify-content:center;
            align-items: center;
            height: 100%;
            padding: 0%;
        }
        .btn:hover{
            border-radius: 5px;
            background-color: rgb(219, 213, 213, 0.3);
        }
        .btn p
        {
            width: 100%;
            height: 100%;
            text-align: left;
            transition: background-color 0.15s;
            border-radius: 3px;
            display: flex;
            align-items: center;
            padding: 0px;
            color: white;
            margin: 3px;
            font-size: 6px;
        }
        .btn:hover div
        {
        background-color: rgba(147, 147, 147, 0.31);
        }
        #blue
        {
        padding : 0px 0;
        }
        #green
        {
        padding : 0px 0;
        }
        #orange {
        padding : 0px 0;
        }
        .vertical {
        border: 1px solid #4d4d4d;
        height: 80%
        }
        #canvas-container{
            /* background: #E086D3; */
            /* R: Only for testing */
            /* height: 85vh; */
        }

 .tooltip-carousel {
  position: relative;
  display: inline-flex;
  justify-content: center;
  align-items: center;
  user-select: none;
  padding: 0px 8px;
  background: #d5d5d5;
  border-radius: 18px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
  height:11px;
}

.tooltip-carousel-content {
  display: flex;
  align-items: center;
  transition: transform 0.3s ease-in-out;
  white-space: nowrap;
}

.tooltip-carousel-item {
  padding: 3px 5px;
  cursor: pointer;
  margin: 0px 0px;
  white-space: nowrap;
  font-size: x-small;
}

.tooltip-carousel-item:hover {
  background: #b1b0b0;
  border-radius: 10px;
}


.carousel-divider {
  height: 24.5px;
  border: 1px solid #ccc;
  margin: 0px 5px;
}

.prev, .next {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  cursor: pointer;
  z-index: 5;
}

.prev {
  left: 10px;
}

.next {
  right: 10px;
}

.tooltip-arrow {
  position: absolute;
  bottom: -9.5px;
  left: 50%;
  width: 0;
  height: 0;
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-top: 10px solid #d5d5d5;
  transform: translateX(-50%);
}
      </style>
</head>
<body>
    <div style="display: flex; flex-direction: column;">
        <div>
            <div style="display: flex;justify-content: center;">
                <button id="rect">Rect</button>
                <button id="circ">Circ</button>
                <button id="save">Save</button>
                <button id="undo">undo</button>
                <button id="redo">redo</button>
                <button id="clear">clear</button>
                <button id="drawing-mode" drawing=false>Enter drawing mode</button><br>
                <p class="save"></p>
                <input type="text" id="text" />
            </div>
            <div style="display: inline-block; margin-left: 10px">
                <div id="drawing-mode-options">
                  <label for="drawing-mode-selector">Mode:</label>
                  <select id="drawing-mode-selector">
                    <option>Pencil</option>
                    <option>Circle</option>
                    <option>Spray</option>
                  </select><br>
              
                  <label for="drawing-line-width">Line width:</label>
                  <span class="info">5</span><input type="range" value="5" min="0" max="150" id="drawing-line-width"><br>
              
                  <label for="drawing-color">Line color:</label>
                  <input type="color" value="#005E7A" id="drawing-color"><br>
              
                  <label for="drawing-shadow-color">Shadow color:</label>
                  <input type="color" value="#005E7A" id="drawing-shadow-color"><br>
              
                  <label for="drawing-shadow-width">Shadow width:</label>
                  <span class="info">0</span><input type="range" value="0" min="0" max="50" id="drawing-shadow-width"><br>
              
                  <label for="drawing-shadow-offset">Shadow offset:</label>
                  <span class="info">0</span><input type="range" value="0" min="0" max="50" id="drawing-shadow-offset"><br>
                </div>
              </div>
        </div>
        <div style="display: flex;justify-content: center;" id="canvas-container">
            <canvas id="c" width="600" height="600" style="border:1px solid #000000"></canvas>
        </div>
    </div>

    <div class="context-menu" id="context-menu">
        <div style="position:absolute;"> <!-- Change position to relative here -->
          <div class="tooltip-carousel"  style="height:auto">
              <div class="tooltip-carousel-content" id="carouselContent" style="height: 100%;width: auto !important;">
                  <!-- Dynamic content will be loaded here -->
              </div>
  
          </div>
          <div class="tooltip-arrow"></div> <!-- Tooltip 'nib' -->
      </div>
      <script src="//cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
      
      <!-- <script>
            
            const orange = document.querySelector("#orange");
            const blue = document.querySelector("#blue");
            const green = document.querySelector("#green");


            document.addEventListener('DOMContentLoaded', (event) => {
                const menu = document.querySelector(".context-menu");
                const canvaswall = document.querySelector("#c");
                canvaswall.addEventListener("contextmenu", function(e) {
                    // Show the context menu
                menu.style.display = "block";
                
                // just for the pen :
                menu.style.transform = "translate(0)";
                
                // set position X of the menu
                if ((window.innerWidth - e.clientX) > menu.offsetWidth + 10){
                    menu.style.left = e.clientX + "px";
                }
                else
                {
                    menu.style.left = (e.clientX - menu.offsetWidth) + "px";
                }
                // set position Y of the menu
                if ((e.clientY) > menu.offsetHeight + 10){   
                menu.style.top = (e.clientY - menu.offsetHeight) + "px";
                }
                else
                {
                    menu.style.top = e.clientY + "px";
                }
                })

                //exit the context menu
                window.addEventListener("click", function(){
                    menu.style.display = "none";
                })
            });
    
            
            
      </script> -->
 <script>
function copyObjectHandler() {
    $('#context-menu').hide();
pastetext.style.display = "flex";
canvas.getActiveObject().clone(function(cloned) {
_clipboard = cloned;
updatePasteButtonVisibility();
// console.log(_clipboard);
})
}

function pasteObjectHandler(e) {
        $('#context-menu').hide();
            console.log(_clipboard);
            _clipboard.clone(function(clonedObj) {
                canvas.discardActiveObject();
                var pointer = canvas.getPointer(e);  // Transform the mouse coordinates
                clonedObj.set({
                    left: pointer.x,
                    top: pointer.y,
                    evented: true,
                });
                if (clonedObj.type === 'activeSelection') {
                    // active selection needs a reference to the canvas.
                    clonedObj.canvas = canvas;
                    clonedObj.forEachObject(function(obj) {
                        canvas.add(obj);
                    });
                    // this should solve the unselectability
                    clonedObj.setCoords();
                } else {
                    canvas.add(clonedObj);
                }
                _clipboard.top += 10;
                _clipboard.left += 10;
                canvas.setActiveObject(clonedObj);
                canvas.requestRenderAll();
            });
            updatePasteButtonVisibility();
}

function updatePasteButtonVisibility() {
    let pasteButton = document.getElementById('paste');
    if (_clipboard) {
        pasteButton.style.display = "flex";
    } else {
        pasteButton.style.display = "none";
    }
}



let _clipboard;
document.addEventListener('keydown', function(event) {
  if (event.ctrlKey || event.metaKey) { // Check for Ctrl key (Windows) or Command key (Mac)
    if (event.key === 'c') {
        copyObjectHandler();
    } else if (event.key === 'v') {
        if (_clipboard) {
	// clone again, so you can do multiple copies.
	_clipboard.clone(function(clonedObj) {
		canvas.discardActiveObject();
		clonedObj.set({
			left: clonedObj.left + 10,
			top: clonedObj.top + 10,
			evented: true,
		});
		if (clonedObj.type === 'activeSelection') {
			// active selection needs a reference to the canvas.
			clonedObj.canvas = canvas;
			clonedObj.forEachObject(function(obj) {
				canvas.add(obj);
			});
			// this should solve the unselectability
			clonedObj.setCoords();
		} else {
			canvas.add(clonedObj);
		}
		_clipboard.top += 10;
		_clipboard.left += 10;
		canvas.setActiveObject(clonedObj);
		canvas.requestRenderAll();
	});
    }
     else {
        console.log('No object has been copied');
    }
    }
  }
});


let carouselData = [
  [
    { value: 'Group', id: 'group', handler: () => {} },
    { value: 'Copy', id: 'copy', handler: copyObjectHandler},
    { value: 'Paste', id: 'paste', handler: pasteObjectHandler},
    { value: '123', handler: () => console.log('Paste clicked') }
  ],
  [
    { value: 4, handler: () => console.log('4 clicked') },
    { value: 5, handler: () => console.log('5 clicked') },
    { value: 6, handler: () => console.log('6 clicked') }
  ],
  [
    { value: 7, handler: () => console.log('7 clicked') },
    { value: 8, handler: () => console.log('8 clicked') }
  ]
];


let menuIndex = 0;

function updateCarousel() {
  const carouselContent = document.querySelector('.tooltip-carousel-content');
  carouselContent.innerHTML = '';

  let slideData = [...carouselData[menuIndex]];

  if (menuIndex > 0) slideData.unshift({ value: '<', handler: () => navigate(-1) });
  if (menuIndex < carouselData.length - 1) slideData.push({ value: '>', handler: () => navigate(1) });

  slideData.forEach((itemData) => {
    if (itemData.value === '<' || itemData.value === '>') {
        itemData.handler = (event) => navigate(itemData.value === '>' ? 1 : -1, event);
    }
    createCarouselItem(itemData, carouselContent);
});

//   adjustCarouselWidth();
}

function createCarouselItem(itemData, carouselContent) {
    let div = document.createElement('div');
    div.className = 'tooltip-carousel-item';
    div.textContent = itemData.value;
    if (itemData.id) {
        div.id = itemData.id; // Assign the id
    }
    div.addEventListener('click', itemData.handler);
    carouselContent.appendChild(div);
}

function addDivider(carouselContent) {
  let divider = document.createElement('div');
  divider.className = 'carousel-divider';
  carouselContent.appendChild(divider);
}

function navigate(direction, event) {
    if (event) {
        event.stopPropagation(); // Prevent the click from being propagated
    }
    
    if (menuIndex + direction >= 0 && menuIndex + direction < carouselData.length) {
        menuIndex += direction;
        updateCarousel();
        updatePasteButtonVisibility(); // Update the visibility of the paste button
        checkGroupedObjects()
    }
}

// function adjustCarouselWidth() {
//   const carouselContent = document.querySelector('.tooltip-carousel-content');
//   let totalWidth = 0;
//   Array.from(carouselContent.children).forEach(child => {
//     const style = window.getComputedStyle(child);
//     const margin = parseInt(style.marginLeft) + parseInt(style.marginRight);

//     totalWidth += child.offsetWidth + margin;
//   });

//   carouselContent.style.width = `${totalWidth}px`;
// }

// Initialize the carousel
updateCarousel();
 </script>
    <script>


        // function calculateHash(obj) {
        //     const hash = CryptoJS.MD5(obj).toString();
        //     return hash;
        // }
        let isGrouped;
        var canvasHistory = [];
        var currentIndex = -1;
        var isUndoRedoOperation = false;
        var historySizeLimit = 20; // Set the maximum size of the history
        var drawingModeEl = document.getElementById('drawing-mode');
        var isDrawing = drawingModeEl.getAttribute('drawing');

        var drawingOptionsEl = document.getElementById('drawing-mode-options');
        var drawingColorEl = document.getElementById('drawing-color');
        var drawingShadowColorEl = document.getElementById('drawing-shadow-color');
        var drawingLineWidthEl = document.getElementById('drawing-line-width');
        var drawingShadowWidth = document.getElementById('drawing-shadow-width');
        var drawingShadowOffset = document.getElementById('drawing-shadow-offset');
        var canvas = new fabric.Canvas('c',{
            fireRightClick: true,
            stopContextMenu: true,
            isDrawingMode: !isDrawing
        });

        let pastetext = document.querySelector("#paste");
        paste.style.display = "none";

        fabric.Object.prototype.transparentCorners = false;
        
        drawingModeEl.onclick = function() {
            canvas.isDrawingMode = !canvas.isDrawingMode;
            if (canvas.isDrawingMode) {
            drawingModeEl.innerHTML = 'Cancel drawing mode';
            drawingOptionsEl.style.display = '';
            }
            else {
            drawingModeEl.innerHTML = 'Enter drawing mode';
            // drawingOptionsEl.style.display = 'none';
            }
        };
        
// start check
// start check
// start check
// start check
// start check
// start check
// start check

        let drawingModeSelector = document.getElementById('drawing-mode-selector');

drawingModeSelector.onchange = function() {
    let isDrawingTool = ['Pencil', 'Circle', 'Spray'].includes(this.value);

    if (isDrawingTool) {
        canvas.isDrawingMode = true;

        switch (this.value) {
            default:
                canvas.freeDrawingBrush = new fabric[this.value + 'Brush'](canvas);
        }
    } else {
        canvas.isDrawingMode = false;
    }

    if (canvas.freeDrawingBrush) {
        canvas.freeDrawingBrush.color = drawingColorEl.value;
        canvas.freeDrawingBrush.width = parseInt(drawingLineWidthEl.value, 10) || 1;
        canvas.freeDrawingBrush.shadow = new fabric.Shadow({
            blur: parseInt(drawingShadowWidth.value, 10) || 0,
            offsetX: 0,
            offsetY: 0,
            affectStroke: true,
            color: drawingShadowColorEl.value,
        });
    }
};

        drawingColorEl.oninput = function() {
            canvas.freeDrawingBrush.color = this.value;
        };
        drawingShadowColorEl.oninput = function() {
            canvas.freeDrawingBrush.shadow.color = this.value;
        };
        drawingLineWidthEl.onchange = function() {
            canvas.freeDrawingBrush.width = parseInt(this.value, 10) || 1;
            this.previousSibling.innerHTML = this.value;
        };
        drawingShadowWidth.onchange = function() {
            canvas.freeDrawingBrush.shadow.blur = parseInt(this.value, 10) || 0;
            this.previousSibling.innerHTML = this.value;
        };
        drawingShadowOffset.onchange = function() {
            canvas.freeDrawingBrush.shadow.offsetX = parseInt(this.value, 10) || 0;
            canvas.freeDrawingBrush.shadow.offsetY = parseInt(this.value, 10) || 0;
            this.previousSibling.innerHTML = this.value;
        };

        if (canvas.freeDrawingBrush) {
            canvas.freeDrawingBrush.color = drawingColorEl.value;
            canvas.freeDrawingBrush.width = parseInt(drawingLineWidthEl.value, 10) || 1;
            canvas.freeDrawingBrush.shadow = new fabric.Shadow({
            blur: parseInt(drawingShadowWidth.value, 10) || 0,
            offsetX: 0,
            offsetY: 0,
            affectStroke: true,
            color: drawingShadowColorEl.value,
            });
        }
        
// original code 
// original code 
// original code 
        // canvas.setBackgroundImage('http://lorempixel.com/400/400/fashion', canvas.renderAll.bind(canvas));

        $(document).bind('contextmenu', function(e) {
            e.preventDefault();
        });


        $("#text").on("click", function() {
            const text = new fabric.Text($("#text").val(), { left: 100, top: 100 });
            canvas.add(text);
        });

        $("#rect").on("click", function() {
            const rect = new fabric.Rect({
                left: 40, top: 40, width: 50, height: 50, fill: 'transparent', stroke: 'green', strokeWidth: 5
            });
            canvas.add(rect);
        });

        $("#circ").on("click", function() {
            const circle = new fabric.Circle({
                left: 40, top: 40, radius: 50, fill: 'transparent', stroke: 'green', strokeWidth: 5
            });
            canvas.add(circle);
        });


        // Function to save the current canvas state to history
        function saveToHistory() {
            if (!isUndoRedoOperation) {
                const currentCanvasState = JSON.stringify(canvas.toJSON());
                // Check if the current state is different from the last saved state
                const lastSavedState = canvasHistory[currentIndex];
                if (currentCanvasState !== lastSavedState) {
                    // Remove any future states if they exist
                    canvasHistory = canvasHistory.slice(0, currentIndex + 1);
                    currentIndex++;
                    canvasHistory[currentIndex] = JSON.stringify(canvas.toJSON());
                    // Drop the oldest states until the history size is within the limit
                    while (canvasHistory.length > historySizeLimit) {
                        canvasHistory.shift();
                        currentIndex--;
                        if (currentIndex < 0) {
                            currentIndex = 0; // Ensures currentIndex doesn't go below 0
                        }
                    }
                }
            }
        }

        // Fabric.js events to detect changes
        canvas.on('object:modified', saveToHistory);
        canvas.on('object:added', saveToHistory);
        const menu = document.querySelector("#context-menu");
        fabric.util.addListener(document.getElementsByClassName('upper-canvas')[0], 'contextmenu', function(e) {
            checkGroupedObjects();
            var cnvsPos = $('#canvas-container').offset();
            curX = e.clientX + cnvsPos.left - 55;
            console.log(curX,cnvsPos.left);
            curY = e.clientY - cnvsPos.top/4;
            console.log(curY,cnvsPos.top);
            // curX = e.clientX - menu.offsetWidth/2;
            // curY = e.clientY - menu.offsetHeight - 10;
            $('#context-menu').css({'top': curY, 'left': curX}).fadeIn('fast');
            //console.log("Position of the cursor point" + curX + "," + curY);
        });
        $(document).click(function(event) {
        if (!$(event.target).closest('#context-menu').length) {
            if ($('#context-menu').css("display", "flex")) {
                $('#context-menu').css("display", "none");
            }
        }
        });


        $(document).on('click', '#group', function(evt) {
            $('#context-menu').hide();
            console.log(isGrouped);
            if (isGrouped) {
                canvas.getActiveObject().toActiveSelection();
                canvas.requestRenderAll();
                isGrouped = false;
            } else {
                canvas.getActiveObject().toGroup();
                canvas.requestRenderAll();
            }
        });










        document.getElementById("undo").addEventListener("click", undo);
        function undo() {
            if (currentIndex > 0) {
                isUndoRedoOperation = true;
                currentIndex--;
                const previousState = canvasHistory[currentIndex];
                canvas.loadFromJSON(previousState, function() {
                    canvas.renderAll();
                    isUndoRedoOperation = false;
                });
            }
        }

        document.getElementById("redo").addEventListener("click", redo);
        function redo() {
            if (currentIndex < canvasHistory.length - 1) {
                isUndoRedoOperation = true;
                currentIndex++;
                const nextState = canvasHistory[currentIndex];
                canvas.loadFromJSON(nextState, function() {
                    canvas.renderAll();
                    isUndoRedoOperation = false;
                });
            }
        }

        document.getElementById("clear").addEventListener("click", function () {
            canvas.clear();
            console.log(canvasHistory);
            console.log(currentIndex);
            console.log(canvasHistory[currentIndex]);
            // canvas.setBackgroundColor('white', canvas.renderAll.bind(canvas));
            saveToHistory();
        });


        // Save initial state
        saveToHistory();
        updatePasteButtonVisibility();


        document.addEventListener('keydown', function(event) {
            // Check if the Ctrl key is pressed (Ctrl key has key code 17)
            if (event.ctrlKey || event.metaKey) {
                // Check for Ctrl+Z (undo) on Windows or Command+Z on Mac
                if ((event.key === 'z' || event.key === 'Z') && !event.shiftKey) {
                    event.preventDefault(); // Prevent the browser's default Ctrl+Z or Command+Z behavior
                    undo(); // Call the undo function
                }
                // Check for Ctrl+R (redo) on Windows or Command+R on Mac
                else if ((event.key === 'r' || event.key === 'R') && !event.shiftKey) {
                    event.preventDefault(); // Prevent the browser's default Ctrl+R or Command+R behavior
                    redo(); // Call the redo function
                }
            }
        });


        // Function to remove the selected object
        function removeSelectedObject() {
            var activeObject = canvas.getActiveObject();
            if (activeObject) {
                canvas.remove(activeObject);
                saveToHistory();
            }
        }

        // Binding the Backspace key to remove the selected object
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Backspace' || event.key === 'Delete') {
                event.preventDefault(); // Prevent the default backspace action
                removeSelectedObject();
            }
        });


        $("#save").on("click", function(e) {
                    $(".save").html(canvas.toSVG());
        });


        function checkGroupedObjects() {
            let group = document.getElementById("group");
            let activeObject = canvas.getActiveObject();
            // Check if there is an active object
            if (activeObject) {
                // Check if the active object is a group
                console.log(activeObject.type);
                if (activeObject && activeObject.type === 'group') {
                    group.style.display = "flex";
                    group.textContent = "Ungroup";
                    isGrouped = true;
                } else {
                    group.style.display = "flex";
                    group.textContent = "Group";
                    isGrouped = false;
                }
            } else {
                // Default text or action when no object is selected
                    group.style.display = "none";
            }
        }



// Sample data points
var dataPoints = [
    { x: 10, y: 50 }, 
    { x: 50, y: 30 },
    { x: 90, y: 70 },
    // Add more points as needed
];

// Function to draw a line between two points
function drawLine(point1, point2) {
    var line = new fabric.Line([point1.x, point1.y, point2.x, point2.y], {
        fill: 'black',
        stroke: 'black',
        strokeWidth: 2,
    });
    canvas.add(line);
}

// Draw the line plot
for (var i = 0; i < dataPoints.length - 1; i++) {
    drawLine(dataPoints[i], dataPoints[i + 1]);
}
    </script>
</body>
</html>

<!-- reference -->
<!-- https://codepen.io/ryjkmr/pen/KKWgVVP -->
<!-- https://codepen.io/Sampathkumar/pen/ZEaQXJ contextMenu -->
<!-- https://codepen.io/notarazi/pen/jaKRjm freedrawing -->

<!-- Bug report -->
<!-- 1. If you click several times on the clear button, duplicate save to history  #solved-->