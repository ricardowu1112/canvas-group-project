<!DOCTYPE html>
<html>
<head>
    <style>
        canvas {
            border: 1px solid black;
        }

        .color-picker {
            margin: 1rem 1rem 0 1rem;
        }
    </style>
</head>
<body>
    <div style="margin-bottom: 20px;">
        <input type="color" class="js-color-picker color-picker">
        <input type="range" class="js-line-range" min="1" max="72" value="1">
        <label class="js-range-value">1</label>Px
    </div>
    <canvas id="myCanvas" width="1200" height="600"></canvas>
    <button onclick="undo()">Undo</button>
    <button onclick="redo()">Redo</button>
    <button onclick="clearCanvas()">Clear</button>
    <button onclick="clearHistory()">Clear History</button>
    <script>


        const colorPicker = document.querySelector('.js-color-picker');
        const lineWidthRange = document.querySelector('.js-line-range');
        const lineWidthLabel = document.querySelector('.js-range-value');

        var canvas = document.getElementById("myCanvas");
        var ctx = canvas.getContext("2d");

        // Define a doubly linked list node structure with an unnamed array as data
        class LinkedListNode {
            constructor() {
                this.data = []; // Store data in an unnamed array
                this.prev = null; // Reference to the previous node
                this.next = null; // Reference to the next node
            }
        }

        // Initialize the doubly linked list node
        let drawingHistoryHead = new LinkedListNode();
        let currentNode = drawingHistoryHead;

        function addToDrawingHistory(path, color, lineWidth) {
            const newData = {
                path: path, // Store the drawing path
                color: color, // Store the drawing color
                lineWidth: lineWidth // Store the line width
            };
            currentNode.data.push(newData); // Add the new data to the current node's array
            redrawCanvas(); // Redraw the canvas with the updated data
        }

        ctx.lineCap = 'round';
        var drawing = false;
        var drawingPath = [];
        // var drawingHistory = [];
        var currentIndex = -1;

        var originalStrokeStyle = 'black'; // Original stroke color
        var originalLineWidth = 1; // Original line width
        var selectedColor = originalStrokeStyle; // Selected color
        var selectedLineWidth = originalLineWidth; // Selected line width

        // Initialize color and line width
        ctx.strokeStyle = selectedColor;
        ctx.lineWidth = selectedLineWidth;

        function startDrawing(event) {
            drawing = true;
            drawingPath = [];
            var x = event.clientX - canvas.getBoundingClientRect().left;
            var y = event.clientY - canvas.getBoundingClientRect().top;
            drawingPath.push({ x, y });
            ctx.beginPath();
            ctx.moveTo(x, y);
        }

        function continueDrawing(event) {
            if (drawing) {
                var x = event.clientX - canvas.getBoundingClientRect().left;
                var y = event.clientY - canvas.getBoundingClientRect().top;
                drawingPath.push({ x, y });

                ctx.lineTo(x, y);
                ctx.stroke();
            }
        }

        function undo() {
            if (currentIndex >= 0) {
                currentIndex--;
                redrawCanvas();

                console.log('Undo last drawing')

            } else if (currentNode.prev) {
                currentNode = currentNode.prev;
                currentIndex = currentNode.data.length - 1;
                redrawCanvas();

                console.log('Undo clear operation')
            }
                
            }

        function redo() {
            if (currentIndex < currentNode.data.length - 1) {
                currentIndex++;
                redrawCanvas();

                console.log('Redo last drawing')

            } else if (currentNode.next) {
                currentNode = currentNode.next;
                currentIndex = -1;
                redrawCanvas();

                console.log('Redo clear operation')
            }
        }

        function stopDrawing(event) {
            if (drawing) {
                drawing = false;
                var smoothedPath = smoothPath(drawingPath);
                // Clear paths after the current index
                currentNode.data = currentNode.data.slice(0, currentIndex + 1);
                currentNode.data.push({
                    path: smoothedPath,
                    color: selectedColor,
                    lineWidth: selectedLineWidth
                });
                currentIndex = currentNode.data.length - 1;

                // Set the next node to null if it exists
                if (currentNode.next) {
                    currentNode.next = null;
                }

                redrawCanvas();
            }
            console.log(drawingHistoryHead)
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (var i = 0; i <= currentIndex; i++) {
                var { path, color, lineWidth } = currentNode.data[i];
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);

                for (var j = 1; j < path.length; j++) {
                    ctx.lineTo(path[j].x, path[j].y);
                }
                ctx.stroke();
            }
            // Restore the current selected color and line width
            ctx.strokeStyle = selectedColor;
            ctx.lineWidth = selectedLineWidth;
        }

        function smoothPath(path) {
            var smoothedPath = [];
            if (path.length < 2) {
                return path;
            }

            // Define the number of points to use for smoothing (more points for smoother curves)
            var numPointsToUse = 5; // You can adjust this number as needed

            // Add the starting point
            smoothedPath.push({ x: path[0].x, y: path[0].y });

            for (var i = 1; i < path.length - 1; i++) {
                var controlPoints = [];

                // Calculate control points using more than 3 consecutive points
                for (var j = Math.max(0, i - numPointsToUse + 1); j <= i; j++) {
                    controlPoints.push(path[j]);
                }

                // Calculate the average position of control points
                var sumX = 0;
                var sumY = 0;
                for (var k = 0; k < controlPoints.length; k++) {
                    sumX += controlPoints[k].x;
                    sumY += controlPoints[k].y;
                }
                var avgX = sumX / controlPoints.length;
                var avgY = sumY / controlPoints.length;

                // Add the average point to the smoothed path
                smoothedPath.push({ x: avgX, y: avgY });
            }

            // Add the ending point
            smoothedPath.push({ x: path[path.length - 1].x, y: path[path.length - 1].y });

            return smoothedPath;
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Create a new empty linked list node
            const newNode = new LinkedListNode();
            // Set the new node as the current node's next node
            newNode.prev = currentNode;
            currentNode.next = newNode;
            // Set the new node as the current node
            currentNode = newNode;
            currentIndex = -1; // Reset the current index
            console.log('Clear canvas')
        }


        function clearHistory() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Reset the head to an empty node
            drawingHistoryHead = new LinkedListNode();
            currentNode = drawingHistoryHead;
            currentIndex = -1; // Reset the current index
            // redrawCanvas(); // Redraw the canvas to reflect the cleared state
            // console.log(drawingHistoryHead)
        }

        colorPicker.addEventListener('change', event => {
            selectedColor = event.target.value;
            ctx.strokeStyle = selectedColor;
        });

        lineWidthRange.addEventListener('input', event => {
            selectedLineWidth = event.target.value;
            lineWidthLabel.innerHTML = selectedLineWidth;
            ctx.lineWidth = selectedLineWidth;
            lineWidthRange.style.cursor = `url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' height='${selectedLineWidth}' width='${selectedLineWidth}'><circle cx='${selectedLineWidth / 2}' cy='${selectedLineWidth / 2}' r='${(selectedLineWidth / 2) - 2}' fill='none' stroke='black' stroke-width='4'/></svg>") ${selectedLineWidth / 2} ${selectedLineWidth / 2}, auto`;
        });

        canvas.addEventListener("mousedown", startDrawing);
        canvas.addEventListener("mousemove", continueDrawing);
        canvas.addEventListener("mouseup", stopDrawing);
        canvas.addEventListener("mouseleave", stopDrawing);
        document.addEventListener('keydown', function(event) {
            
            // Check if the Ctrl key is pressed (Ctrl key has key code 17)
            if (event.ctrlKey) {
                // Check for Ctrl+Z (undo)
                if (event.key === 'z' || event.key === 'Z') {
                    event.preventDefault(); // Prevent the browser's default Ctrl+Z behavior
                    undo(); // Call the undo function
                }
                // Check for Ctrl+R (redo)
                else if (event.key === 'r' || event.key === 'R') {
                    event.preventDefault(); // Prevent the browser's default Ctrl+R behavior
                    redo(); // Call the redo function
                }
            }
        });
    </script>
</body>
</html>
